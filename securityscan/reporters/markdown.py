"""
Markdown report generator for SecurityScan.
"""

from pathlib import Path
from typing import Dict, Any

from ..models import ScanResult, Severity, IssueCategory


class MarkdownReporter:
    """Markdown report generator."""
    
    def __init__(self, config):
        self.config = config
    
    def generate_report(self, result: ScanResult, output_file: Path):
        """Generate Markdown report."""
        markdown_content = self._generate_markdown_content(result)
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(markdown_content)
    
    def _generate_markdown_content(self, result: ScanResult) -> str:
        """Generate complete Markdown content."""
        stats = result.statistics
        
        # Security score emoji
        score = stats.security_score
        if score >= 90:
            score_emoji = "🎉"
            score_message = "Excellent! Your code is very secure!"
        elif score >= 70:
            score_emoji = "👍"
            score_message = "Good security practices detected."
        elif score >= 50:
            score_emoji = "⚠️"
            score_message = "Some security improvements needed."
        else:
            score_emoji = "🚨"
            score_message = "Critical security issues found!"
        
        markdown = f"""# 🔒 SecurityScan Report

**Project:** {result.project_path.name}  
**Scan Date:** {result.scan_timestamp.strftime('%Y-%m-%d %H:%M:%S')}  
**Scanner Version:** {result.scanner_version}

## 📊 Security Summary

{score_emoji} **Security Score: {score}/100**  
{score_message}

| Metric | Value |
|--------|-------|
| Total Issues | {stats.total_issues} |
| Files Scanned | {stats.files_scanned} |
| Files with Issues | {stats.files_with_issues} |
| Scan Duration | {stats.scan_duration:.2f}s |

## 🔍 Issues by Severity

"""
        
        # Issues by severity
        for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW, Severity.INFO]:
            count = stats.issues_by_severity[severity]
            if count > 0:
                emoji = {"critical": "🔴", "high": "🟠", "medium": "🟡", "low": "🔵", "info": "🟢"}
                markdown += f"- {emoji[severity.value]} **{severity.value.title()}:** {count} issues\n"
        
        # Issues by category
        markdown += "\n## 📋 Issues by Category\n\n"
        top_categories = sorted(
            stats.issues_by_category.items(),
            key=lambda x: x[1],
            reverse=True
        )[:10]
        
        for category, count in top_categories:
            if count > 0:
                category_name = category.value.replace('_', ' ').title()
                markdown += f"- **{category_name}:** {count} issues\n"
        
        # Detailed issues
        if result.issues:
            markdown += "\n## 🔎 Detailed Issues\n\n"
            markdown += self._generate_detailed_issues_markdown(result)
        else:
            markdown += "\n## 🎉 No Issues Found\n\nGreat job! No security issues were detected in your code.\n"
        
        # Recommendations
        markdown += "\n## 💡 Recommendations\n\n"
        markdown += self._generate_recommendations_markdown(stats)
        
        # Footer
        markdown += f"\n---\n\n*Generated by SecurityScan v{result.scanner_version}*"
        
        return markdown
    
    def _generate_detailed_issues_markdown(self, result: ScanResult) -> str:
        """Generate detailed issues section in Markdown."""
        markdown = ""
        
        # Group issues by severity
        issues_by_severity = {}
        for issue in result.issues:
            if issue.severity not in issues_by_severity:
                issues_by_severity[issue.severity] = []
            issues_by_severity[issue.severity].append(issue)
        
        # Generate issues by severity
        for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW, Severity.INFO]:
            if severity in issues_by_severity:
                issues = issues_by_severity[severity]
                emoji = {"critical": "🔴", "high": "🟠", "medium": "🟡", "low": "🔵", "info": "🟢"}
                
                markdown += f"### {emoji[severity.value]} {severity.value.title()} Issues ({len(issues)})\n\n"
                
                # Group issues by file
                issues_by_file = {}
                for issue in issues:
                    file_path = issue.file_path
                    if file_path not in issues_by_file:
                        issues_by_file[file_path] = []
                    issues_by_file[file_path].append(issue)
                
                for file_path, file_issues in issues_by_file.items():
                    markdown += f"#### 📁 {file_path}\n\n"
                    
                    for issue in file_issues:
                        markdown += self._generate_single_issue_markdown(issue)
                        markdown += "\n"
        
        return markdown
    
    def _generate_single_issue_markdown(self, issue) -> str:
        """Generate Markdown for a single issue."""
        markdown = f"**⚠️ {issue.title}**\n\n"
        markdown += f"*Line {issue.line_number}, Column {issue.column_number}*\n\n"
        markdown += f"{issue.description}\n\n"
        
        # Code snippet
        if issue.code_snippet:
            markdown += "**Code:**\n"
            markdown += "```python\n"
            markdown += issue.code_snippet
            markdown += "\n```\n\n"
        
        # Fix suggestion
        if issue.fix_suggestion:
            markdown += f"**💡 Fix:** {issue.fix_suggestion}\n\n"
        
        # References
        if issue.references:
            markdown += "**📚 References:**\n"
            for ref in issue.references[:3]:  # Show max 3 references
                markdown += f"- [{ref}]({ref})\n"
            markdown += "\n"
        
        # Tags
        if issue.tags:
            tags_text = " ".join([f"`#{tag}`" for tag in sorted(issue.tags)])
            markdown += f"**Tags:** {tags_text}\n\n"
        
        markdown += "---\n\n"
        
        return markdown
    
    def _generate_recommendations_markdown(self, stats) -> str:
        """Generate recommendations section in Markdown."""
        recommendations = []
        
        if stats.issues_by_severity.get(Severity.CRITICAL, 0) > 0:
            recommendations.append({
                "title": "Fix Critical Issues",
                "description": "Address critical security vulnerabilities immediately as they pose the highest risk."
            })
        
        if stats.issues_by_severity.get(Severity.HIGH, 0) > 0:
            recommendations.append({
                "title": "Address High Severity Issues",
                "description": "Plan to fix high-severity issues soon as they can lead to serious security breaches."
            })
        
        if stats.issues_by_severity.get(Severity.MEDIUM, 0) > 0:
            recommendations.append({
                "title": "Review Medium Severity Issues",
                "description": "Schedule fixes for medium-severity issues in upcoming development cycles."
            })
        
        if stats.issues_by_category.get(IssueCategory.SECRET, 0) > 0:
            recommendations.append({
                "title": "Secure Secret Management",
                "description": "Implement proper secret management using environment variables or secret management services."
            })
        
        if stats.issues_by_category.get(IssueCategory.DEPENDENCY, 0) > 0:
            recommendations.append({
                "title": "Update Dependencies",
                "description": "Keep dependencies up to date and use tools like Dependabot for automated updates."
            })
        
        if not recommendations:
            recommendations.append({
                "title": "Maintain Security Practices",
                "description": "Continue following security best practices and perform regular security scans."
            })
        
        markdown = ""
        for i, rec in enumerate(recommendations, 1):
            markdown += f"{i}. **{rec['title']}**\n   - {rec['description']}\n\n"
        
        return markdown
